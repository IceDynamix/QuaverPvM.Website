<template>
    <div
        class="submission-container"
        v-if="secondsLeft > 0"
    >
        <div class="left-side side">
            <MatchTimer :secondsLeft="secondsLeft"/>
        </div>
        <div class="right-side side">
            <div class="submission-buttons">
                <div class="submission-selection">
                    <Button
                        :click="onYesButton"
                        v-tooltip.right="submitYesTooltip"
                        buttonText="SUBMIT"
                        icon="send"
                    />
                </div>
                <div class="submission-selection">
                    <Button
                        :click="onNoButton"
                        v-tooltip.right="submitNoTooltip"
                        buttonText="RESIGN"
                        icon="flag"
                    />
                </div>
            </div>
            <transition name="fade" mode="in-out">
                <div
                    class="submission-scan-loading"
                    v-if="scanLoading === true"
                >
                    <LoadingSpinner/>
                </div>
            </transition>
        </div>
    </div>
</template>

<script>
import axios from "axios";
import Button from "../Elements/Button";
import LoadingSpinner from "../Elements/LoadingSpinner";
import MatchTimer from "./MatchTimer";

export default {
    name: "MatchSubmission",
    components: { Button, LoadingSpinner, MatchTimer },
    props: {
        endsAt: Date
    },
    data: function () {
        return { secondsLeft: null, scanLoading: false };
    },
    created() {
        setTimeout(this.countdown, 1000);
    },
    methods: {
        onYesButton: async function () {
            if (this.scanLoading) {
                this.$toasted.show("Already scanning!");
                return;
            }
            try {
                this.scanLoading = true;
                let response = await axios.post("results");
                let { success, message, plays } = response.data;
                if (success) {
                    this.$toasted.show(
                        `Submitted a win successfully (${ plays[0].accuracy.toFixed(
                            2,
                        ) }%)`,
                    );
                    this.secondsLeft = null;
                    this.$store.commit("setMatch", null);
                    this.$store.dispatch(
                        "fetchEntityDatapointsCurrent",
                        this.$store.state.user.loggedInUser,
                    );
                } else {
                    this.$toasted.show(message, { type: "info" });
                }
            } catch (e) {
                this.$toasted.show(e.response.data.err, { type: "error" });
                this.$store.dispatch("requestMatch");
                this.$store.dispatch(
                    "fetchEntityDatapointsCurrent",
                    this.$store.state.user.loggedInUser,
                );
            }
            this.scanLoading = false;
        },
        onNoButton: async function () {
            if (this.scanLoading) {
                this.$toasted.show("Already resigning!");
                return;
            }
            let confirmation = confirm("Are you sure you want to resign?");
            if (!confirmation) return;
            try {
                this.scanLoading = true;
                let response = await axios.post("results", { giveUp: true });
                let { success, message } = response.data;
                if (success) {
                    this.$toasted.show("Resigned successfully");
                    this.secondsLeft = null;
                    this.$store.commit("setMatch", null);
                    this.$store.dispatch(
                        "fetchEntityDatapointsCurrent",
                        this.$store.state.user.loggedInUser,
                    );
                } else {
                    this.$toasted.show(message, { type: "info" });
                }
            } catch (e) {
                this.$toasted.show(e, { type: "error" });
            }
            this.scanLoading = false;
        },
        countdown: function () {
            if (this.match) {
                const currentTime = new Date();
                this.secondsLeft =
                    (new Date(this.match.endsAt).getTime() -
                        currentTime.getTime()) /
                    1000;

                // User timed out
                if (this.secondsLeft < 0) {
                    this.secondsLeft = null;
                    this.$toasted.show("Timed out, match is considered lost");
                    this.$store.commit("setMatch", null);
                    this.$store.dispatch(
                        "fetchEntityDatapointsCurrent",
                        this.$store.state.user.loggedInUser,
                    );
                }
            }
            setTimeout(this.countdown, 1000);
        },
    },
    computed: {
        submitYesTooltip() {
            return "Scan for recent plays";
        },
        submitNoTooltip() {
            return "Give up on this one";
        },
        match() {
            return this.$store.state.match.match;
        },
    },
}
</script>

<style scoped>
.submission-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    height: 60px;
    margin-top: 30px;
}

.submission-selection {
    flex: 1;
}

.submission-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    height: inherit;
}

.submission-scan-loading {
    margin: 10px;
}
.side {
    margin: 10px;
    height: inherit;
}

.left-side {
    flex: 1;
    text-align: right;
}

.right-side {
    flex: 1;
    text-align: left;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
}
</style>